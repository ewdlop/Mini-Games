æƒåœ°é›· python with tinker

import tkinter as tk
from tkinter import messagebox
import random

class MineSweeper:
    def __init__(self, master):
        self.master = master
        self.master.title('æƒé›·éŠæˆ²')
        self.rows = 9
        self.cols = 9
        self.mines = 10
        self.buttons = []
        self.mines_positions = []
        self.game_over = False
        
        # å‰µå»ºéŠæˆ²å€åŸŸ
        self.create_board()
        # æ”¾ç½®åœ°é›·
        self.place_mines()
        
    def create_board(self):
        # å‰µå»ºæŒ‰éˆ•ç¶²æ ¼
        for i in range(self.rows):
            row = []
            for j in range(self.cols):
                button = tk.Button(self.master, width=2, height=1)
                button.grid(row=i, column=j)
                button.bind('<Button-1>', lambda e, row=i, col=j: self.click(row, col))
                button.bind('<Button-3>', lambda e, row=i, col=j: self.flag(row, col))
                row.append(button)
            self.buttons.append(row)
    
    def place_mines(self):
        # éš¨æ©Ÿæ”¾ç½®åœ°é›·
        mine_positions = []
        while len(mine_positions) < self.mines:
            pos = (random.randint(0, self.rows-1), random.randint(0, self.cols-1))
            if pos not in mine_positions:
                mine_positions.append(pos)
        self.mines_positions = mine_positions
    
    def count_adjacent_mines(self, row, col):
        # è¨ˆç®—å‘¨åœåœ°é›·æ•¸é‡
        count = 0
        for i in range(-1, 2):
            for j in range(-1, 2):
                r, c = row + i, col + j
                if (r, c) in self.mines_positions:
                    count += 1
        return count
    
    def click(self, row, col):
        if self.game_over:
            return
            
        button = self.buttons[row][col]
        
        # æª¢æŸ¥æ˜¯å¦é»åˆ°åœ°é›·
        if (row, col) in self.mines_positions:
            button.config(text="ğŸ’£", bg='red')
            self.game_over = True
            messagebox.showinfo("éŠæˆ²çµæŸ", "è¸©åˆ°åœ°é›·äº†ï¼")
            self.reveal_all_mines()
        else:
            # é¡¯ç¤ºå‘¨åœåœ°é›·æ•¸é‡
            mines = self.count_adjacent_mines(row, col)
            button.config(text=str(mines), state='disabled')
            if mines == 0:
                self.reveal_empty_cells(row, col)
    
    def flag(self, row, col):
        if self.game_over:
            return
            
        button = self.buttons[row][col]
        if button['text'] == '':
            button.config(text='ğŸš©')
        elif button['text'] == 'ğŸš©':
            button.config(text='')
    
    def reveal_empty_cells(self, row, col):
        # éè¿´é¡¯ç¤ºç©ºç™½æ ¼å­
        for i in range(-1, 2):
            for j in range(-1, 2):
                r, c = row + i, col + j
                if (0 <= r < self.rows and 
                    0 <= c < self.cols and 
                    self.buttons[r][c]['state'] != 'disabled'):
                    mines = self.count_adjacent_mines(r, c)
                    self.buttons[r][c].config(text=str(mines), state='disabled')
                    if mines == 0:
                        self.reveal_empty_cells(r, c)
    
    def reveal_all_mines(self):
        # éŠæˆ²çµæŸæ™‚é¡¯ç¤ºæ‰€æœ‰åœ°é›·
        for row, col in self.mines_positions:
            self.buttons[row][col].config(text="ğŸ’£", bg='red')

def main():
    root = tk.Tk()
    game = MineSweeper(root)
    root.mainloop()

if __name__ == '__main__':
    main()


add restart dialog


// ... existing code ...

class MineSweeper:
    def __init__(self, master):
        # ... existing init code ...
        
        # æ·»åŠ é‡æ–°é–‹å§‹æŒ‰éˆ•
        self.restart_button = tk.Button(self.master, text="é‡æ–°é–‹å§‹", command=self.restart_game)
        self.restart_button.grid(row=self.rows, columnspan=self.cols, pady=10)

    def click(self, row, col):
        if self.game_over:
            return
            
        button = self.buttons[row][col]
        
        # æª¢æŸ¥æ˜¯å¦é»åˆ°åœ°é›·
        if (row, col) in self.mines_positions:
            button.config(text="ğŸ’£", bg='red')
            self.game_over = True
            self.reveal_all_mines()
            # ä¿®æ”¹éŠæˆ²çµæŸå°è©±æ¡†ï¼Œæ·»åŠ é‡æ–°é–‹å§‹é¸é …
            if messagebox.askyesno("éŠæˆ²çµæŸ", "è¸©åˆ°åœ°é›·äº†ï¼\nè¦é‡æ–°é–‹å§‹å—ï¼Ÿ"):
                self.restart_game()
        else:
            # ... existing click code ...
    
    def restart_game(self):
        # é‡ç½®æ‰€æœ‰æŒ‰éˆ•
        for i in range(self.rows):
            for j in range(self.cols):
                self.buttons[i][j].config(
                    text="",
                    state="normal",
                    bg='SystemButtonFace'  # æ¢å¾©é»˜èªèƒŒæ™¯è‰²
                )
        
        # é‡ç½®éŠæˆ²ç‹€æ…‹
        self.game_over = False
        
        # é‡æ–°æ”¾ç½®åœ°é›·
        self.place_mines()

// ... existing code ...


right clikc for flag

def create_board(self):
    for i in range(self.rows):
        row = []
        for j in range(self.cols):
            button = tk.Button(self.master, width=2, height=1)
            button.grid(row=i, column=j)
            # ç¶å®šå³éµäº‹ä»¶åˆ°flagæ–¹æ³•
            button.bind('<Button-3>', lambda e, row=i, col=j: self.flag(row, col))
            row.append(button)
        self.buttons.append(row)

def flag(self, row, col):
    if self.game_over:
        return
        
    button = self.buttons[row][col]
    # åˆ‡æ›æ——å¹Ÿç‹€æ…‹
    if button['text'] == '':
        button.config(text='ğŸš©')
    elif button['text'] == 'ğŸš©':
        button.config(text='')